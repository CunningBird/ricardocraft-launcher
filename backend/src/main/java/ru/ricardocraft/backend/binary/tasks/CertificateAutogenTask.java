package ru.ricardocraft.backend.binary.tasks;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x500.X500NameBuilder;
import org.bouncycastle.asn1.x500.style.BCStyle;
import org.bouncycastle.asn1.x509.ExtendedKeyUsage;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.KeyPurposeId;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaCertStore;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.cms.CMSException;
import org.bouncycastle.cms.CMSSignedDataGenerator;
import org.bouncycastle.cms.SignerInfoGenerator;
import org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.DigestCalculatorProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;
import org.bouncycastle.util.Store;
import ru.ricardocraft.backend.manangers.KeyAgreementManager;
import ru.ricardocraft.backend.properties.LaunchServerProperties;

import java.io.IOException;
import java.math.BigInteger;
import java.nio.file.Path;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class CertificateAutogenTask implements LauncherBuildTask {

    private transient final Logger logger = LogManager.getLogger(CertificateAutogenTask.class);

    private final transient LaunchServerProperties properties;
    private final transient KeyAgreementManager keyAgreementManager;
    public X509Certificate certificate;
    public X509CertificateHolder bcCertificate;
    public CMSSignedDataGenerator signedDataGenerator;

    public CertificateAutogenTask(LaunchServerProperties properties, KeyAgreementManager keyAgreementManager) {
        this.properties = properties;
        this.keyAgreementManager = keyAgreementManager;
    }

    @Override
    public String getName() {
        return "CertificateAutogen";
    }

    @Override
    public Path process(Path inputFile) throws IOException {
        if (signedDataGenerator != null) return inputFile;
        try {
            logger.warn("You are using an auto-generated certificate (sign.enabled false). It is not good");
            logger.warn("It is highly recommended that you use the correct certificate (sign.enabled true)");
            logger.warn("You can use GenerateCertificateModule or your own certificate.");
            X500NameBuilder subject = new X500NameBuilder();
            subject.addRDN(BCStyle.CN, properties.getProjectName().concat(" Autogenerated"));
            subject.addRDN(BCStyle.O, properties.getProjectName());
            LocalDateTime startDate = LocalDate.now().atStartOfDay();
            X509v3CertificateBuilder builder = new X509v3CertificateBuilder(
                    subject.build(),
                    new BigInteger("0"),
                    Date.from(startDate.atZone(ZoneId.systemDefault()).toInstant()),
                    Date.from(startDate.plusDays(3650).atZone(ZoneId.systemDefault()).toInstant()),
                    new X500Name("CN=ca"),
                    SubjectPublicKeyInfo.getInstance(keyAgreementManager.ecdsaPublicKey.getEncoded()));
            builder.addExtension(Extension.extendedKeyUsage, false, new ExtendedKeyUsage(KeyPurposeId.id_kp_codeSigning));
            //builder.addExtension(Extension.keyUsage, false, new KeyUsage(1));
            JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder("SHA256WITHECDSA");
            ContentSigner signer = csBuilder.build(keyAgreementManager.ecdsaPrivateKey);
            bcCertificate = builder.build(signer);
            certificate = new JcaX509CertificateConverter().setProvider("BC")
                    .getCertificate(bcCertificate);
            ArrayList<Certificate> chain = new ArrayList<>();
            chain.add(certificate);
            signedDataGenerator = createSignedDataGenerator(keyAgreementManager.ecdsaPrivateKey, certificate, chain, "SHA256WITHECDSA");
        } catch (OperatorCreationException | CMSException | CertificateException e) {
            logger.error("Certificate generate failed", e);
        }
        return inputFile;
    }

    private CMSSignedDataGenerator createSignedDataGenerator(PrivateKey privateKey,
                                                                   Certificate cert,
                                                                   List<Certificate> certChain,
                                                                   String signAlgo) throws OperatorCreationException,
            CertificateEncodingException, CMSException {
        @SuppressWarnings("rawtypes")
        Store certStore = new JcaCertStore(certChain);
        ContentSigner signer = new JcaContentSignerBuilder(signAlgo).setProvider("BC").build(privateKey);
        CMSSignedDataGenerator generator = new CMSSignedDataGenerator();
        DigestCalculatorProvider dcp = new JcaDigestCalculatorProviderBuilder().setProvider("BC").build();
        SignerInfoGenerator sig = new JcaSignerInfoGeneratorBuilder(dcp).build(signer, (X509Certificate) cert);
        generator.addSignerInfoGenerator(sig);
        generator.addCertificates(certStore);
        return generator;
    }
}
